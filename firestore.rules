rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper: Check if user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper: Check if usage is by the owner
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    // Helper: Check if user is a member of the team
    function isTeamMember(teamId) {
       return isSignedIn() && 
         exists(/databases/$(database)/documents/teams/$(teamId)) &&
         request.auth.uid in get(/databases/$(database)/documents/teams/$(teamId)).data.members;
    }

    // Users collection rules
    match /users/{userId} {
      // Allow create/delete only by owner
      allow create, delete: if isOwner(userId);
      
      // Allow update by owner OR by team leader (for kicking members)
      allow update: if isOwner(userId) || (
        resource.data.teamId != null && 
        exists(/databases/$(database)/documents/teams/$(resource.data.teamId)) &&
        get(/databases/$(database)/documents/teams/$(resource.data.teamId)).data.leaderId == request.auth.uid
      );
      
      // Allow read if owner OR if they are in the same team
      allow read: if isOwner(userId) || (
        isSignedIn() && 
        resource.data.teamId != null && 
        // Read the requester's teamId to compare
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.teamId == resource.data.teamId
      );
    }

    // Teams collection rules
    match /teams/{teamId} {
      // Any authenticated user can create a team
      allow create: if isSignedIn() && request.resource.data.leaderId == request.auth.uid;
      
      // Read/List allowed for authenticated users (required for joining via invite code)
      // Note: We'd prefer to restrict this to members, but 'joinTeam' requires querying by inviteCode
      // before membership is established.
      allow read: if isSignedIn();
      
      // Update rules:
      // Allow if Leader (can change everything)
      // OR if Member/New User performs a constrained update
      allow update: if (
        // Leader can do anything
        resource.data.leaderId == request.auth.uid
      ) || (
        // Non-leaders must NOT change critical fields
        request.resource.data.leaderId == resource.data.leaderId &&
        request.resource.data.inviteCode == resource.data.inviteCode &&
        request.resource.data.name == resource.data.name &&
        request.resource.data.createdAt == resource.data.createdAt &&
        
        // And their update must be valid:
        (
          // Case A: Existing member updating stats or leaving
          (
            resource.data.members.hasAny([request.auth.uid]) && 
            (
              // Updating stats (members unchanged)
              request.resource.data.members.hasAll(resource.data.members) &&
              resource.data.members.hasAll(request.resource.data.members)
            ) || (
              // OR Leaving (removing ONLY self)
              resource.data.members.hasAll(request.resource.data.members) &&
              !request.resource.data.members.hasAny([request.auth.uid])
            )
          ) ||
          // Case B: New user joining (adding ONLY self)
          (
            !resource.data.members.hasAny([request.auth.uid]) &&
            request.resource.data.members.hasAll(resource.data.members) &&
            request.resource.data.members.hasAny([request.auth.uid]) &&
            request.resource.data.members.size() == resource.data.members.size() + 1
          )
        )
      );
      
      // Delete: Only members (typically leader or last member)
      allow delete: if isSignedIn() && resource.data.members.hasAny([request.auth.uid]);

      // Revealed Segments subcollection (Strict privacy)
      match /revealedSegments/{segmentId} {
        allow read, write: if isTeamMember(teamId);
      }
    }
  }
}
